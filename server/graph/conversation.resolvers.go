package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/timothydarren/WebTY/graph/model"
)

// CreateConversation is the resolver for the createConversation field.
func (r *mutationResolver) CreateConversation(ctx context.Context, inputConversation model.NewConversation) (*model.Conversation, error) {
	conversation := &model.Conversation{
		ID:      uuid.NewString(),
		Userid1: inputConversation.Userid1,
		Userid2: inputConversation.Userid2,
		Date:    time.Now().Format("2006-01-02 15:04:05"),
	}

	return conversation, r.DB.Save(&conversation).Error
}

// GetAllConversationByUserID is the resolver for the getAllConversationByUserId field.
func (r *queryResolver) GetAllConversationByUserID(ctx context.Context, userid string, name *string) ([]*model.ConversationHeader, error) {
	var conversations []*model.Conversation
	query := r.DB.Where("userid1 = ? OR userid2 = ?", userid, userid)

	if name != nil && *name != "" {
		query = query.Joins("JOIN users ON users.id = userid1 OR users.id = userid2").
			Where("users.firstname ILIKE ? OR users.surname ILIKE ?", "%"+*name+"%", "%"+*name+"%")
	}

	if err := query.Find(&conversations).Error; err != nil {
		return nil, err
	}

	conversationHeaders := make([]*model.ConversationHeader, 0, len(conversations))

	for _, conversation := range conversations {
		user1, err := r.GetUser(context.Background(), conversation.Userid1)
		if err != nil {
			return nil, err
		}

		user2, err := r.GetUser(context.Background(), conversation.Userid2)
		if err != nil {
			return nil, err
		}

		conversationHeader := &model.ConversationHeader{
			ID:    conversation.ID,
			User1: user1,
			User2: user2,
		}

		conversationHeaders = append(conversationHeaders, conversationHeader)
	}

	return conversationHeaders, nil
}
