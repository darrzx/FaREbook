package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/timothydarren/WebTY/graph/model"
)

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, inputGroup model.NewGroup) (*model.Group, error) {
	createGroup := &model.Group{
		ID:         uuid.NewString(),
		Name:       inputGroup.Name,
		Privacy:    inputGroup.Privacy,
		Profilepic: "https://res.cloudinary.com/dnl7josxn/image/upload/v1692952250/createGroup_cwvcrt.png",
		Date:       time.Now().Format("2006-01-02 15:04:05"),
	}
	return createGroup, r.DB.Save(&createGroup).Error
}

// CreateGroupMember is the resolver for the createGroupMember field.
func (r *mutationResolver) CreateGroupMember(ctx context.Context, inputGroupMember model.NewGroupMember) (*model.GroupMember, error) {
	groupMember := &model.GroupMember{
		ID:      uuid.NewString(),
		Groupid: inputGroupMember.Groupid,
		Userid:  inputGroupMember.Userid,
		Role:    inputGroupMember.Role,
	}
	return groupMember, r.DB.Save(&groupMember).Error
}

// CreateGroupInvited is the resolver for the createGroupInvited field.
func (r *mutationResolver) CreateGroupInvited(ctx context.Context, inputGroupInvited model.NewGroupInvited) (*model.GroupInvited, error) {
	groupInvited := &model.GroupInvited{
		ID:      uuid.NewString(),
		Groupid: inputGroupInvited.Groupid,
		Userid:  inputGroupInvited.Userid,
	}
	return groupInvited, r.DB.Save(&groupInvited).Error
}

// CreateGroupRequest is the resolver for the createGroupRequest field.
func (r *mutationResolver) CreateGroupRequest(ctx context.Context, inputGroupRequest model.NewGroupRequestJoin) (*model.GroupRequestJoin, error) {
	groupRequest := &model.GroupRequestJoin{
		ID:      uuid.NewString(),
		Groupid: inputGroupRequest.Groupid,
		Userid:  inputGroupRequest.Userid,
	}
	return groupRequest, r.DB.Save(&groupRequest).Error
}

// CreateGroupPost is the resolver for the createGroupPost field.
func (r *mutationResolver) CreateGroupPost(ctx context.Context, inputGroupPost model.NewGroupPost, medias []string) (*model.GroupPost, error) {
	post := &model.GroupPost{
		ID:           uuid.NewString(),
		Groupid:      inputGroupPost.Groupid,
		Groupname:    inputGroupPost.Groupname,
		Date:         time.Now().Format("2006-01-02"),
		Text:         inputGroupPost.Text,
		Privacy:      inputGroupPost.Privacy,
		Commentcount: 0,
		Likecount:    0,
	}

	if err := r.DB.Save(&post).Error; err != nil {
		return nil, err
	}

	if len(medias) > 0 {
		for _, media := range medias {
			inputMediaPost := model.NewMediaPost{
				Postid: post.ID,
				Media:  media,
			}
			if _, err := r.CreateMediaPost(ctx, inputMediaPost); err != nil {
				return nil, err
			}
		}
	}

	return post, nil
}

// DeleteGroupMemberByUserID is the resolver for the deleteGroupMemberByUserId field.
func (r *mutationResolver) DeleteGroupMemberByUserID(ctx context.Context, groupid string, userid string) (*model.GroupMember, error) {
	var member *model.GroupMember
	if err := r.DB.First(&member, "groupid = ? AND userid = ?", groupid, userid).Error; err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&member).Error; err != nil {
		return nil, err
	}

	var remainingMembers int64
	if err := r.DB.Model(&model.GroupMember{}).Where("groupid = ?", groupid).Count(&remainingMembers).Error; err != nil {
		return nil, err
	}

	if remainingMembers == 0 {
		if err := r.DB.Delete(&model.GroupPost{}, "groupid = ?", groupid).Error; err != nil {
			return nil, err
		}

		if err := r.DB.Delete(&model.GroupRequestJoin{}, "groupid = ?", groupid).Error; err != nil {
			return nil, err
		}

		if err := r.DB.Delete(&model.GroupInvited{}, "groupid = ?", groupid).Error; err != nil {
			return nil, err
		}

		var group model.Group
		if err := r.DB.First(&group, "id = ?", groupid).Error; err != nil {
			return nil, err
		}

		if err := r.DB.Delete(&group).Error; err != nil {
			return nil, err
		}
	}
	return member, nil
}

// DeleteGroupRequestByUserID is the resolver for the deleteGroupRequestByUserId field.
func (r *mutationResolver) DeleteGroupRequestByUserID(ctx context.Context, groupid string, userid string) (*model.GroupRequestJoin, error) {
	var user *model.GroupRequestJoin
	if err := r.DB.First(&user, "groupid = ? AND userid = ?", groupid, userid).Error; err != nil {
		return nil, err
	}
	return user, r.DB.Delete(&user).Error
}

// GetGroup is the resolver for the getGroup field.
func (r *queryResolver) GetGroup(ctx context.Context, id string) (*model.Group, error) {
	var group *model.Group
	return group, r.DB.First(&group, "id = ?", id).Error
}

// GetAllGroup is the resolver for the getAllGroup field.
func (r *queryResolver) GetAllGroup(ctx context.Context) ([]*model.Group, error) {
	var groups []*model.Group
	return groups, r.DB.Find(&groups).Error
}

// GetAllGroupByUserID is the resolver for the getAllGroupByUserId field.
func (r *queryResolver) GetAllGroupByUserID(ctx context.Context, userid string) ([]*model.GroupHeader, error) {
	var groups []*model.GroupMember
	query := r.DB.Where("userid = ?", userid)

	if err := query.Find(&groups).Error; err != nil {
		return nil, err
	}

	groupHeaders := make([]*model.GroupHeader, 0, len(groups))

	for _, group := range groups {
		group1, err := r.GetGroup(context.Background(), group.Groupid)
		if err != nil {
			return nil, err
		}

		groupHeader := &model.GroupHeader{
			ID:    group.ID,
			Group: group1,
		}

		groupHeaders = append(groupHeaders, groupHeader)
	}

	return groupHeaders, nil
}

// GetAllGroupByName is the resolver for the getAllGroupByName field.
func (r *queryResolver) GetAllGroupByName(ctx context.Context, name *string) ([]*model.Group, error) {
	var groups []*model.Group
	query := r.DB

	query = query.Where("name ILIKE ? AND privacy LIKE ?", "%"+*name+"%", "Public")

	if err := query.Find(&groups).Error; err != nil {
		return nil, err
	}
	return groups, nil
}

// GetAllGroupPost is the resolver for the getAllGroupPost field.
func (r *queryResolver) GetAllGroupPost(ctx context.Context, offset *int, limit *int, groupids []string) ([]*model.GroupPost, error) {
	if groupids == nil || len(groupids) == 0 {
		return nil, nil
	}

	var posts []*model.GroupPost

	query := r.DB
	if len(groupids) > 0 {
		query = query.Where("groupid IN (?)", groupids)
	}

	if limit != nil {
		query = query.Limit(*limit)
	}
	if offset != nil {
		query = query.Offset(*offset)
	}

	if err := query.Find(&posts).Error; err != nil {
		return nil, err
	}

	fetchPosts := make([]*model.GroupPost, 0, len(posts))

	for _, post := range posts {
		fetchPost := &model.GroupPost{
			ID:           post.ID,
			Groupid:      post.Groupid,
			Groupname:    post.Groupname,
			Date:         post.Date,
			Text:         post.Text,
			Privacy:      post.Privacy,
			Commentcount: 0,
			Likecount:    0,
		}

		var commentcount int64
		if err := r.DB.Model(&model.CommentPost{}).Where("postid = ?", post.ID).Count(&commentcount).Error; err != nil {
			return nil, err
		}

		fetchPost.Commentcount = int(commentcount)

		var likecount int64
		if err := r.DB.Model(&model.LikePost{}).Where("postid = ? AND is_like = ?", post.ID, true).Count(&likecount).Error; err != nil {
			return nil, err
		}

		fetchPost.Likecount = int(likecount)

		fetchPosts = append(fetchPosts, fetchPost)
	}

	return fetchPosts, nil
}

// GetAllPostByGroupID is the resolver for the getAllPostByGroupId field.
func (r *queryResolver) GetAllPostByGroupID(ctx context.Context, groupid string) ([]*model.GroupPost, error) {
	var posts []*model.GroupPost

	if err := r.DB.Where("groupid = ?", groupid).Find(&posts).Error; err != nil {
		return nil, err
	}

	fetchPosts := make([]*model.GroupPost, 0, len(posts))

	for _, post := range posts {
		fetchPost := &model.GroupPost{
			ID:           post.ID,
			Groupid:      post.Groupid,
			Groupname:    post.Groupname,
			Date:         post.Date,
			Text:         post.Text,
			Privacy:      post.Privacy,
			Commentcount: 0,
			Likecount:    0,
		}

		var commentcount int64
		if err := r.DB.Model(&model.CommentPost{}).Where("postid = ?", post.ID).Count(&commentcount).Error; err != nil {
			return nil, err
		}

		fetchPost.Commentcount = int(commentcount)

		var likecount int64
		if err := r.DB.Model(&model.LikePost{}).Where("postid = ? AND is_like = ?", post.ID, true).Count(&likecount).Error; err != nil {
			return nil, err
		}

		fetchPost.Likecount = int(likecount)

		fetchPosts = append(fetchPosts, fetchPost)
	}

	return fetchPosts, nil
}

// GetAllUserRequestByGroupID is the resolver for the getAllUserRequestByGroupId field.
func (r *queryResolver) GetAllUserRequestByGroupID(ctx context.Context, groupid string) ([]*model.User, error) {
	var userRequests []*model.GroupRequestJoin
	if err := r.DB.Where("groupid = ?", groupid).Find(&userRequests).Error; err != nil {
		return nil, err
	}

	var userIDs []string
	for _, user := range userRequests {
		userIDs = append(userIDs, user.Userid)
	}

	var users []*model.User
	if err := r.DB.Where("id IN (?)", userIDs).Find(&users).Error; err != nil {
		return nil, err
	}

	return users, nil
}

// CheckMemberByUserid is the resolver for the checkMemberByUserid field.
func (r *queryResolver) CheckMemberByUserid(ctx context.Context, groupid string, userid string) (bool, error) {
	var member model.GroupMember
	err := r.DB.Model(&member).
		Where("groupid = ?", groupid).
		Where("userid = ?", userid).
		First(&member).Error

	if err != nil {
		return false, nil
	}

	return true, nil
}

// CheckRequestByUserid is the resolver for the checkRequestByUserid field.
func (r *queryResolver) CheckRequestByUserid(ctx context.Context, groupid string, userid string) (bool, error) {
	var member model.GroupRequestJoin
	err := r.DB.Model(&member).
		Where("groupid = ?", groupid).
		Where("userid = ?", userid).
		First(&member).Error

	if err != nil {
		return false, nil
	}

	return true, nil
}

// CheckMemberIsAdmin is the resolver for the checkMemberIsAdmin field.
func (r *queryResolver) CheckMemberIsAdmin(ctx context.Context, groupid string, userid string) (bool, error) {
	var member model.GroupMember
	err := r.DB.Model(&member).
		Where("groupid = ?", groupid).
		Where("userid = ?", userid).
		Where("role = ?", "Admin").
		First(&member).Error

	if err != nil {
		return false, nil
	}

	return true, nil
}
